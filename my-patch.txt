Return-Path: <brooklyngrant@u.boisestate.edu>
Received: from codespaces-75a93d.wqafff5oxx3unlavkmpkilcynd.xx.internal.cloudapp.net ([4.155.45.99])
        by smtp.gmail.com with ESMTPSA id d2e1a72fcca58-71afc834795sm3079188b3a.41.2024.09.25.12.47.47
        for <brooklyngrant@u.boisestate.edu>
        (version=TLS1_3 cipher=TLS_AES_256_GCM_SHA384 bits=256/256);
        Wed, 25 Sep 2024 12:47:47 -0700 (PDT)
From: Brooklyn Grant <brooklyngrant@u.boisestate.edu>
To: brooklyngrant@u.boisestate.edu
Subject: [PATCH] Submit project
Date: Wed, 25 Sep 2024 19:47:12 +0000
Message-ID: <20240925194712.7072-1-brooklyngrant@u.boisestate.edu>
X-Mailer: git-send-email 2.46.0
MIME-Version: 1.0
Content-Transfer-Encoding: 8bit

---
 .vscode/settings.json |   7 +
 app/main.c            | 331 +++++++++++++++++++++++++++++++++++++++++-
 src/lab.h             | 130 ++++++++++++++++-
 tests/test-lab.c      | 165 ++++++++++++++++++++-
 4 files changed, 625 insertions(+), 8 deletions(-)
 create mode 100644 .vscode/settings.json

diff --git a/.vscode/settings.json b/.vscode/settings.json
new file mode 100644
index 0000000..cd1bd89
--- /dev/null
+++ b/.vscode/settings.json
@@ -0,0 +1,7 @@
+{
+    "C_Cpp.errorSquiggles": "disabled",
+    "files.associations": {
+        "readline.h": "c",
+        "string.h": "c"
+    }
+}
\ No newline at end of file
diff --git a/app/main.c b/app/main.c
index 302d926..adbfbeb 100644
--- a/app/main.c
+++ b/app/main.c
@@ -1,7 +1,332 @@
+#include <ctype.h>
 #include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include "../src/lab.h"
+#include <readline/readline.h>
+#include <readline/history.h>
+#include <pwd.h>
+#include <sys/types.h>
+#include <sys/wait.h>
+#include <signal.h>
+#include <termios.h>
+
+
+// objects (structs for c)
+typedef struct {
+    int id;
+    pid_t pid;
+    char command[300]; // command typed
+    char status[8]; // running or done
+} Job;
+
+// global vars
+struct termios shell_tmodes;
+pid_t shell_pgid;
+int shell_terminal;
+
+#define MAX_JOBS 100 // 100 is the max jobs for now
+Job jobList[MAX_JOBS];
+int jobCount = 0;
+int nextJobID = 1; // keep track of id to use
+
+
+// Function to change directory
+void change_directory(char *path) {
+    char *home = getenv("HOME");
+
+    if (path == NULL || strcmp(path, "") == 0) {
+        printf("No directory specified. Switching to HOME directory.\n");
+        if (home == NULL) { // home note set, set it manually with user info
+            struct passwd *pw = getpwuid(getuid());
+            if (pw != NULL) {
+                home = pw->pw_dir; 
+            } else {
+                printf("Error: cannot find home directory\n");
+                return;
+            }
+        }
+        int ret = chdir(home); // go to directory since not NULL anymore
+        if (ret != 0) {
+            printf("Error changing directory\n");
+        } else {
+            printf("Successfully changed directory to: '%s'\n", home);
+        }
+    } else {
+        int ret = chdir(path);
+        if (ret != 0) {
+            printf("Error changing directory\n");
+        } else {
+            printf("Successfully changed directory to: '%s'\n", path);
+        }
+    }
+}
+
+// Function to print command history
+void print_history() {
+    printf("Command History: \n");
+
+    HIST_ENTRY **historyList = history_list();
+    if (historyList != NULL) {
+        for (int i = 0; historyList[i] != NULL; i++) {
+            printf("%d: %s\n", i + 1, historyList[i]->line);
+        }
+    }
+}
+
+
+
+/*
+Job handling start-----------------------------------------
+*/
+
+// Function to add a job to the list
+void addJob(pid_t pid, char *command) {
+    if (jobCount < MAX_JOBS) {
+        jobList[jobCount].id = nextJobID++;
+        jobList[jobCount].pid = pid;
+
+        snprintf(jobList[jobCount].command, sizeof(jobList[jobCount].command), "%s", command);
+        snprintf(jobList[jobCount].status, sizeof(jobList[jobCount].status), "Running"); // set status to running
+
+        printf("[%d] %d %s\n", jobList[jobCount].id, pid, command);
+        jobCount++;
+    } else {
+        fprintf(stderr, "Too many jobs\n");
+    }
+}
+
+// Function to remove a job from the list
+void removeJob(pid_t pid) {
+    for (int i = 0; i < jobCount; i++) {
+        if (jobList[i].pid == pid) {
+            // shifting
+            for (int j = i; j < jobCount - 1; j++) {
+                jobList[j] = jobList[j + 1];
+            }
+
+            jobCount--;
+            break;
+        }
+    }
+}
+
+// Function to check for completed background jobs and mark as done if so
+void checkForBackgroundJobs() {
+    int status;
+    pid_t pid;
+
+    for (int i = 0; i < jobCount; i++) {
+        pid = waitpid(jobList[i].pid, &status, WNOHANG);
+
+        if (pid > 0) {
+            // Process has finished
+            snprintf(jobList[i].status, sizeof(jobList[i].status), "Done");
+        }
+    }
+}
+
+void printJobs() {
+    for (int i = 0; i < jobCount; i++) {
+        if (strcmp(jobList[i].status, "Done") == 0) {
+            // done
+            printf("[%d] %s\t %s\n", jobList[i].id, jobList[i].status, jobList[i].command);
+
+            // If the job is done, remove it so it is gone from the list
+            removeJob(jobList[i].pid);
+            i--;
+        } else {
+            // running still
+            printf("[%d] %d %s %s\n", jobList[i].id, jobList[i].pid, jobList[i].status, jobList[i].command);
+
+        }
+    }
+}
+
+/*
+Job handling end-----------------------------------------
+*/
+
+
+// Function to runs command with args
+void runCommand(char **args, int bg, char *command) {
+    pid_t pid = fork();
+
+    if (pid < 0) {
+        fprintf(stderr, "Fork failed");
+        return;
+    }
+
+    if (pid == 0) {
+        // child
+        pid_t child = getpid();
+        setpgid(child, child);
+        if (!bg) {
+            tcsetpgrp(shell_terminal, child); // do not give away control
+        }
+        signal (SIGINT, SIG_DFL);
+        signal (SIGQUIT, SIG_DFL);
+        signal (SIGTSTP, SIG_DFL);
+        signal (SIGTTIN, SIG_DFL);
+        signal (SIGTTOU, SIG_DFL);
+        int ret = execvp(args[0], args);
+
+        if (ret == -1) {
+            fprintf(stderr, "Exec failed\n");
+        }
+        exit(EXIT_FAILURE);
+    } else {
+        // parent
+        setpgid(pid, pid);  // put child in own process group
+
+        if (bg) {
+            // if wanted in background, put there
+            addJob(pid, command);
+        } else {
+
+            tcsetpgrp(shell_terminal, pid);  // give child terminal control
+
+            int status;
+            waitpid(pid, &status, WUNTRACED); //wait for chlid then run
+
+            // Give terminal control to shell again
+            tcsetpgrp(shell_terminal, shell_pgid);
+            tcgetattr(shell_terminal, &shell_tmodes);
+            tcsetattr(shell_terminal, TCSADRAIN, &shell_tmodes);
+
+        }
+    }
+}
+
+
+int main(int argc, char **argv)
+{   
+    // check if asking for the version
+
+  int c;
+
+  while ((c = getopt(argc, argv, "v")) != -1) {
+    switch (c)
+    {
+      case 'v': 
+        printf("Shell version: %d.%d\n", lab_VERSION_MAJOR, lab_VERSION_MINOR);
+        exit(EXIT_SUCCESS);
+        break;
+        
+      case '?': // case outside a b or c
+        if (isprint(optopt))
+          fprintf(stderr, "Unknown option `-%c`.\n", optopt);
+        else
+          fprintf(stderr, "Unknown option character `\\x%x`.\n", optopt);
+        return 1;
+        break;
+
+      default:
+        break;
+    }
+  }
+
+  // if not asking for version and starting terminal, continue here
+
+  signal(SIGINT, SIG_IGN); // Ctrl+C ignore
+  signal(SIGQUIT, SIG_IGN); // ctrl+\ ignore
+  signal(SIGTSTP, SIG_IGN); // ctrl+Z ignore
+  signal(SIGTTIN, SIG_IGN);
+  signal(SIGTTOU, SIG_IGN);
+
+  shell_terminal = STDIN_FILENO;
+
+  if (isatty(shell_terminal)) {
+    // Ensure the shell is in the foreground
+    while (tcgetpgrp(shell_terminal) != (shell_pgid = getpgrp())) {
+        kill(-shell_pgid, SIGTTIN);  // Stop the shell until it's in the foreground
+    }
+
+    // Set the shell process group
+    shell_pgid = getpid();
+    if (setpgid(shell_pgid, shell_pgid) < 0) {
+        perror("Couldn't put the shell in its own process group");
+        exit(1);
+    }
+
+    // Take control of the terminal
+    tcsetpgrp(shell_terminal, shell_pgid);
+
+    // Save the terminal attributes
+    tcgetattr(shell_terminal, &shell_tmodes);
+  }
+  
+  long arg_max = sysconf(_SC_ARG_MAX); // system max arg amount
+
+  char *args[arg_max / sizeof(char *)];
+
+  char *line;
+  using_history();
+  
+  // get prompt, it will be what shows up before typing
+  char *prompt = getenv("MY_PROMPT"); // check if env variable exists
+  
+  if (prompt == NULL) {
+      prompt = "$> "; // default if null
+  }
+
+  while ((line=readline(prompt))){
+    checkForBackgroundJobs(); // while here, check real quick if any bg jobs are finished
+
+    if (*line) {
+      add_history(line);
+
+      int putToBackground = 0;
+      char *command = strdup(line); // command that was typed
+
+      char *ampersand = strrchr(line, '&');
+      if (ampersand) {
+          putToBackground = 1;
+          *ampersand = '\0';  // get rif of &
+          
+          while (isspace((unsigned char) line[strlen(line) - 1])) { // remove spaces before & as well since it doesn't matter
+              line[strlen(line) - 1] = '\0';
+          }
+      }
+
+
+      int i = 0;
+      char *token = strtok(line, " ");
+      while (token != NULL && i < arg_max / sizeof(char *)) {
+          args[i++] = token;
+          token = strtok(NULL, " ");
+      }
+      args[i] = NULL;
+
+      // if empty, leave be and continue
+      if (i == 0) {
+          free(line);
+          continue;
+      }
+
+      if (strcmp(args[0], "exit") == 0) {
+        exit(0);  // exit with status 0
+      } else if (strcmp(args[0], "cd") == 0) {
+          change_directory(args[1]);  // change directory
+          free(line);
+          continue; 
+      } else if (strcmp(args[0], "history") == 0) {
+          print_history();  // print the cmd history
+          free(line);
+          continue; 
+      } else if (strcmp(args[0], "jobs") == 0) {
+          printJobs(); // print all jobs
+          free(line);
+          continue;
+
+      }
+      
+      runCommand(args, putToBackground, command);
+      free(command);
+    }
+
+    free(line);
+  }
 
-int main(void)
-{
-  printf("hello world\n");
   return 0;
 }
diff --git a/src/lab.h b/src/lab.h
index 75ef662..b0afb84 100644
--- a/src/lab.h
+++ b/src/lab.h
@@ -1 +1,129 @@
-/**Update this file with the starter code**/
+#ifndef LAB_H
+#define LAB_H
+#include <stdlib.h>
+#include <stdbool.h>
+#include <sys/types.h>
+#include <termios.h>
+#include <unistd.h>
+
+#define lab_VERSION_MAJOR 1
+#define lab_VERSION_MINOR 0
+#define UNUSED(x) (void)x;
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+  struct shell
+  {
+    int shell_is_interactive;
+    pid_t shell_pgid;
+    struct termios shell_tmodes;
+    int shell_terminal;
+    char *prompt;
+  };
+
+
+
+  /**
+   * @brief Set the shell prompt. This function will attempt to load a prompt
+   * from the requested environment variable, if the environment variable is
+   * not set a default prompt of "shell>" is returned.  This function calls
+   * malloc internally and the caller must free the resulting string.
+   *
+   * @param env The environment variable
+   * @return const char* The prompt
+   */
+  char *get_prompt(const char *env);
+
+  /**
+   * Changes the current working directory of the shell. Uses the linux system
+   * call chdir. With no arguments the users home directory is used as the
+   * directory to change to.
+   *
+   * @param dir The directory to change to
+   * @return  On success, zero is returned.  On error, -1 is returned, and
+   * errno is set to indicate the error.
+   */
+  int change_dir(char **dir);
+
+  /**
+   * @brief Convert line read from the user into to format that will work with
+   * execvp. We limit the number of arguments to ARG_MAX loaded from sysconf.
+   * This function allocates memory that must be reclaimed with the cmd_free
+   * function.
+   *
+   * @param line The line to process
+   *
+   * @return The line read in a format suitable for exec
+   */
+  char **cmd_parse(char const *line);
+
+  /**
+   * @brief Free the line that was constructed with parse_cmd
+   *
+   * @param line the line to free
+   */
+  void cmd_free(char ** line);
+
+  /**
+   * @brief Trim the whitespace from the start and end of a string.
+   * For example "   ls -a   " becomes "ls -a". This function modifies
+   * the argument line so that all printable chars are moved to the
+   * front of the string
+   *
+   * @param line The line to trim
+   * @return The new line with no whitespace
+   */
+  char *trim_white(char *line);
+
+
+  /**
+   * @brief Takes an argument list and checks if the first argument is a
+   * built in command such as exit, cd, jobs, etc. If the command is a
+   * built in command this function will handle the command and then return
+   * true. If the first argument is NOT a built in command this function will
+   * return false.
+   *
+   * @param sh The shell
+   * @param argv The command to check
+   * @return True if the command was a built in command
+   */
+  bool do_builtin(struct shell *sh, char **argv);
+
+  /**
+   * @brief Initialize the shell for use. Allocate all data structures
+   * Grab control of the terminal and put the shell in its own
+   * process group. NOTE: This function will block until the shell is
+   * in its own program group. Attaching a debugger will always cause
+   * this function to fail because the debugger maintains control of
+   * the subprocess it is debugging.
+   *
+   * @param sh
+   */
+  void sh_init(struct shell *sh);
+
+  /**
+   * @brief Destroy shell. Free any allocated memory and resources and exit
+   * normally.
+   *
+   * @param sh
+   */
+  void sh_destroy(struct shell *sh);
+
+  /**
+   * @brief Parse command line args from the user when the shell was launched
+   *
+   * @param argc Number of args
+   * @param argv The arg array
+   */
+  void parse_args(int argc, char **argv);
+
+
+
+#ifdef __cplusplus
+} // extern "C"
+#endif
+
+#endif
\ No newline at end of file
diff --git a/tests/test-lab.c b/tests/test-lab.c
index a5e130d..14cf90d 100644
--- a/tests/test-lab.c
+++ b/tests/test-lab.c
@@ -1,3 +1,4 @@
+#include <string.h>
 #include "harness/unity.h"
 #include "../src/lab.h"
 
@@ -10,12 +11,168 @@ void tearDown(void) {
   // clean stuff up here
 }
 
-void test_stuff(void){
-  // test stuff here
+
+void test_cmd_parse2(void)
+{
+     //The string we want to parse from the user.
+     //foo -v
+     char *stng = (char*)malloc(sizeof(char)*7);
+     strcpy(stng, "foo -v");
+     char **actual = cmd_parse(stng);
+     //construct our expected output
+     size_t n = sizeof(char*) * 6;
+     char **expected = (char**) malloc(sizeof(char*) *6);
+     memset(expected,0,n);
+     expected[0] = (char*)malloc(sizeof(char)*4);
+     expected[1] = (char*)malloc(sizeof(char)*3);
+     expected[2] = (char*)NULL;
+
+     strcpy(expected[0], "foo");
+     strcpy(expected[1], "-v");
+     TEST_ASSERT_EQUAL_STRING(expected[0],actual[0]);
+     TEST_ASSERT_EQUAL_STRING(expected[1],actual[1]);
+     TEST_ASSERT_FALSE(actual[2]);
+     free(expected[0]);
+     free(expected[1]);
+     free(expected);
+}
+
+void test_cmd_parse(void)
+{
+     char **rval = cmd_parse("ls -a -l");
+     TEST_ASSERT_TRUE(rval);
+     TEST_ASSERT_EQUAL_STRING("ls", rval[0]);
+     TEST_ASSERT_EQUAL_STRING("-a", rval[1]);
+     TEST_ASSERT_EQUAL_STRING("-l", rval[2]);
+     TEST_ASSERT_EQUAL_STRING(NULL, rval[3]);
+     TEST_ASSERT_FALSE(rval[3]);
+     cmd_free(rval);
+}
+
+void test_trim_white_no_whitespace(void)
+{
+     char *line = (char*) calloc(10, sizeof(char));
+     strncpy(line, "ls -a", 10);
+     char *rval = trim_white(line);
+     TEST_ASSERT_EQUAL_STRING("ls -a", rval);
+     free(line);
+}
+
+void test_trim_white_start_whitespace(void)
+{
+     char *line = (char*) calloc(10, sizeof(char));
+     strncpy(line, "  ls -a", 10);
+     char *rval = trim_white(line);
+     TEST_ASSERT_EQUAL_STRING("ls -a", rval);
+     free(line);
+}
+
+void test_trim_white_end_whitespace(void)
+{
+     char *line = (char*) calloc(10, sizeof(char));
+     strncpy(line, "ls -a  ", 10);
+     char *rval = trim_white(line);
+     TEST_ASSERT_EQUAL_STRING("ls -a", rval);
+     free(line);
+}
+
+void test_trim_white_both_whitespace_single(void)
+{
+     char *line = (char*) calloc(10, sizeof(char));
+     strncpy(line, " ls -a ", 10);
+     char *rval = trim_white(line);
+     TEST_ASSERT_EQUAL_STRING("ls -a", rval);
+     free(line);
+}
+
+void test_trim_white_both_whitespace_double(void)
+{
+     char *line = (char*) calloc(10, sizeof(char));
+     strncpy(line, "  ls -a  ", 10);
+     char *rval = trim_white(line);
+     TEST_ASSERT_EQUAL_STRING("ls -a", rval);
+     free(line);
+}
+
+void test_trim_white_all_whitespace(void)
+{
+     char *line = (char*) calloc(10, sizeof(char));
+     strncpy(line, "  ", 10);
+     char *rval = trim_white(line);
+     TEST_ASSERT_EQUAL_STRING("", rval);
+     free(line);
+}
+
+void test_trim_white_mostly_whitespace(void)
+{
+     char *line = (char*) calloc(10, sizeof(char));
+     strncpy(line, "    a    ", 10);
+     char *rval = trim_white(line);
+     TEST_ASSERT_EQUAL_STRING("a", rval);
+     free(line);
+}
+
+void test_get_prompt_default(void)
+{
+     char *prompt = get_prompt("MY_PROMPT");
+     TEST_ASSERT_EQUAL_STRING(prompt, "shell>");
+     free(prompt);
+}
+
+void test_get_prompt_custom(void)
+{
+     const char* prmpt = "MY_PROMPT";
+     if(setenv(prmpt,"foo>",true)){
+          TEST_FAIL();
+     }
+
+     char *prompt = get_prompt(prmpt);
+     TEST_ASSERT_EQUAL_STRING(prompt, "foo>");
+     free(prompt);
+     unsetenv(prmpt);
+}
+
+void test_ch_dir_home(void)
+{
+     char *line = (char*) calloc(10, sizeof(char));
+     strncpy(line, "cd", 10);
+     char **cmd = cmd_parse(line);
+     char *expected = getenv("HOME");
+     change_dir(cmd);
+     char *actual = getcwd(NULL,0);
+     TEST_ASSERT_EQUAL_STRING(expected, actual);
+     free(line);
+     free(actual);
+     cmd_free(cmd);
+}
+
+void test_ch_dir_root(void)
+{
+     char *line = (char*) calloc(10, sizeof(char));
+     strncpy(line, "cd /", 10);
+     char **cmd = cmd_parse(line);
+     change_dir(cmd);
+     char *actual = getcwd(NULL,0);
+     TEST_ASSERT_EQUAL_STRING("/", actual);
+     free(line);
+     free(actual);
+     cmd_free(cmd);
 }
 
 int main(void) {
   UNITY_BEGIN();
-  RUN_TEST(test_stuff);
+  RUN_TEST(test_cmd_parse);
+  RUN_TEST(test_cmd_parse2);
+  RUN_TEST(test_trim_white_no_whitespace);
+  RUN_TEST(test_trim_white_start_whitespace);
+  RUN_TEST(test_trim_white_end_whitespace);
+  RUN_TEST(test_trim_white_both_whitespace_single);
+  RUN_TEST(test_trim_white_both_whitespace_double);
+  RUN_TEST(test_trim_white_all_whitespace);
+  RUN_TEST(test_get_prompt_default);
+  RUN_TEST(test_get_prompt_custom);
+  RUN_TEST(test_ch_dir_home);
+  RUN_TEST(test_ch_dir_root);
+
   return UNITY_END();
-}
+}
\ No newline at end of file
-- 
2.46.0
